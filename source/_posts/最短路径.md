---
title: æœ€çŸ­è·¯å¾„
date: 2021-12-22 18:43:50
tags: å›¾è®º
categories: ç®—æ³•
---

# æœ€çŸ­è·¯å¾„ï¼ˆDijkstraç®—æ³•ï¼‰



## è½¬è½½ç½‘ä¸Šå¤§ä½¬çš„å¸–å­ï¼šhttps://www.jianshu.com/p/b24708c9b7b7

è¿™ä»£ç å®ç°æˆ‘æ˜¯çœŸä½©æœï¼ï¼ï¼ï¼ï¼ğŸ‚å‘€



ç®—æ³•æ€è·¯ï¼š

1.ä»ä¸€ä¸ªèµ·ç‚¹å¼€å§‹ï¼Œæ‰¾å‡ºæ‰€æœ‰é‚»æ¥èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ›´æ–°ä»–åˆ°é‚»æ¥èŠ‚ç‚¹çš„æƒå€¼å’Œé‚»æ¥èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ï¼Œ**å¹¶è®¾ç½®å½“å‰èµ·ç‚¹å·²è®¿é—®**ï¼Œä»é‚»æ¥èŠ‚ç‚¹çš„æƒå€¼ä¸­é€‰æ‹©ä¸€ä¸ªæœ€å°çš„ä½œä¸ºä¸‹ä¸€è½®çš„èµ·ç‚¹ï¼Œ

æ¯”å¦‚è¯´L: Aåˆ°Bçš„æƒå€¼ä¸º5ï¼ŒAåˆ°Cçš„æƒå€¼ä¸º2  æˆ‘ä»¬å°±è®¾ç½®ä¸‹ä¸€è½®èµ·ç‚¹ä¸ºCï¼Œå¹¶ä¸”è®¾ç½®Aå·²ç»è®¿é—®ã€‚

2.é‡å¤ä»¥ä¸Šæ“ä½œã€‚

3.ç„¶åæ›´æ–°è®°å½•çš„æƒå€¼ï¼Œä»åŸå§‹èµ·ç‚¹åˆ°å½“å‰èµ·ç‚¹çš„æƒå€¼+åˆ°å½“å‰èµ·ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„æƒå€¼<å·²è®°å½•çš„å½“é‚»æ¥èŠ‚ç‚¹çš„æƒå€¼Â·Â·Â·

ä¸‹é¢ä»£ç ä¹Ÿæ˜¯è½¬è½½çš„ï¼Œæˆ‘çœŸæ²¡è¿™ä¸ªå®åŠ›å‘€ç°åœ¨ã€‚ã€‚ã€‚ã€‚ã€‚ï¼ˆè®©æˆ‘ç†Ÿæ‚‰ç†Ÿæ‚‰é€»è¾‘åº”è¯¥ä¹Ÿå¯ä»¥å®ç°ç›¸ä¿¡è‡ªå·±ï¼‰

```java
enum Status {  // èŠ‚ç‚¹å¯¹è±¡çš„çŠ¶æ€
    // æœªè¢«å‘ç°, å·²è¢«éå†
    UNDISCOVERD, VISITED
}
public class Graph<T> {
    private int N; // Nä¸ªèŠ‚ç‚¹
    public int[][] matrix;  // é‚»æ¥çŸ©é˜µ
    private Status[] statuses;  // ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€
    private T[] datas;  // ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„æ•°æ®
    public Graph(int N) {
        this.N = N;
        matrix = new int[N][N];
        statuses = new Status[N];
        datas = (T[]) new Object[N];  // æ³›å‹æ•°ç»„å®ä¾‹åŒ–
        initStatuses();
    }

    /**
     * ç”¨ä¼ è¿›æ¥çš„çŸ©é˜µåˆå§‹åŒ–å›¾çš„é‚»æ¥çŸ©é˜µ
     *
     * @param matrix ä¼ è¿›æ¥ç”¨äºåˆå§‹åŒ–é‚»æ¥çŸ©é˜µçš„çŸ©é˜µ
     * @return void
     */
    public void setMatrix(int[][] matrix) {
        this.matrix = matrix;
    }


    /**
     * ä½¿å›¾å˜æˆæ— å‘å›¾(æŠŠé‚»æ¥çŸ©é˜µé•œåƒåŒ–)
     *
     * @return void
     */
    public void makeUndirected() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] > 0 && matrix[i][j] != matrix[j][i]) {
                    matrix[j][i] = matrix[i][j];
                }
            }
        }
    }

    public void setDatas(T[] datas) {
        this.datas = datas;
    }

    /**
     * åˆå§‹åŒ–çŠ¶æ€æ•°ç»„
     *
     * @return void
     */
    public void initStatuses() {
        for (int i = 0; i < N; i++) {
            statuses[i] = Status.UNDISCOVERD;
        }
    }

    /**
     * é‚»æ¥çŸ©é˜µä¿å­˜çš„ä¿¡æ¯æ˜¯ä»ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯
     *
     * @param from   ä»è¿™ä¸ªèŠ‚ç‚¹
     * @param to     æŒ‡å‘è¿™ä¸ªèŠ‚ç‚¹
     * @param weight è·¯å¾„æƒé‡
     * @return void
     */
    public void setMatrix(int from, int to, int weight) {
        matrix[from][to] = weight;
    }

    /**
     * æœ€çŸ­è·¯å¾„-è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•(æ‰¾å‡ºæŸä¸ªç‚¹åˆ°å…¶ä»–æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯å¾„)
     *
     * @param index æŒ‡å®šæŸä¸ªç‚¹
     * @return void
     */
    public void DijkstraPath(int index) {
        // æ¯ä¸€è½®é€‰å‡ºçš„è·¯å¾„æƒå€¼æœ€å°çš„èŠ‚ç‚¹, åˆ™ä¸å¯èƒ½å†æ‰¾å‡ºå¦å¤–çš„è·¯å¾„æƒå€¼æ›´å°
        // æ¯”å¦‚ä»Aåˆ°Dæ˜¯2, åˆ™è¿™ä¸€è½®å–å‡ºDèŠ‚ç‚¹, å‡å¦‚æœ‰Aèƒ½é€šè¿‡å¦å¤–çš„èŠ‚ç‚¹åˆ°è¾¾Då¹¶ä¸”æ›´çŸ­,
        // æ¯”å¦‚A-1-E-1-D, åˆ™ä¸Šä¸€è½®å–å‡ºçš„èŠ‚ç‚¹å°†æ˜¯Eè€Œä¸æ˜¯D
        // æ•°ç»„å­˜æ”¾è¯¥ç‚¹åˆ°å„ä¸ªç‚¹çš„è·¯å¾„æƒå€¼
        int[] weights = new int[N];
        // å°†æ¯ä¸ªé»˜è®¤æƒå€¼è®¾ç½®ä¸ºæ•´å‹æœ€å¤§å€¼
        for (int i = 0; i < N; i++) {
            weights[i] = Integer.MAX_VALUE;
        }
        // æ•°ç»„è®°å½•æŒ‡å®šèŠ‚ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸­, ç»ˆç‚¹èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹
        // åŠ¨æ€è§„åˆ’: æ‰¾åˆ°åˆ°è¾¾æŸä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„, å…ˆæ‰¾åˆ°åˆ°è¾¾ä»–çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
        int[] prevs = new int[N];
        prevs[index] = -1;  // è´Ÿæ•°è¡¨ç¤ºè¯¥ç‚¹æ²¡æœ‰å‰é©±
        // å¾ªç¯æ‰€ç”¨çš„è¾…åŠ©ç´¢å¼•
        int from = index;
        // åªè¦ä¸æ˜¯å…¨éƒ¨è¢«éå†
        while (!isAllVisited()) {
            // å°†è¿™ä¸ªèŠ‚ç‚¹è®¾ç½®ä¸ºå·²è®¿é—®
            statuses[from] = Status.VISITED;
            // æŸ¥çœ‹é‚»æ¥çŸ©é˜µä¸­ä¸æŒ‡å®šèŠ‚ç‚¹é‚»æ¥çš„èŠ‚ç‚¹
            for (int i = 0; i < N; i++) {
                // å¯èƒ½çš„æ–°è·¯å¾„æƒå€¼: ä»æœ€å¼€å§‹çš„æŒ‡å®šèµ·ç‚¹åˆ°æœ¬è½®èµ·ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„æƒå€¼æ€»å’Œ
                int newWeight;
                if (weights[from] == Integer.MAX_VALUE) {
                    newWeight = matrix[from][i];
                } else {
                    newWeight = weights[from] + matrix[from][i];
                }
                // å¦‚æœèŠ‚ç‚¹æœªè®¿é—®, ä¸”æ˜¯é‚»æ¥èŠ‚ç‚¹
                if (statuses[i] == Status.UNDISCOVERD && matrix[from][i] > 0
                        // å¹¶ä¸”å¦‚æœå°äºweightsä¸­è®°å½•çš„è¯¥èŠ‚ç‚¹åŸæ¥çš„è·¯å¾„æƒå€¼
                        && newWeight < weights[i]) {
                    // åˆ™æ›´æ–°è¯¥èŠ‚ç‚¹çš„æœ€å°è·¯å¾„å€¼, æ›´æ–°è¯¥èŠ‚ç‚¹çš„å‰é©±ä¸ºæœ¬è½®èµ·ç‚¹
                    weights[i] = newWeight;
                    prevs[i] = from;
                }
            }
            // ä¸‹è½®èµ·ç‚¹fromè®¾ç½®ä¸º: weightsæ•°ç»„ä¸­æ•°å€¼æœ€å°çš„å¹¶ä¸”æœªè®¿é—®çš„èŠ‚ç‚¹
            from = indexOfMin(weights);
        }
        // è¾“å‡ºç»“æœ
        System.out.println("æŒ‡å®šèµ·ç‚¹ä¸º:" + datas[index]);
        for (int i = 0; i < N; i++) {
            if (i != index) {  // é™¤å»æœ€å¼€å§‹æŒ‡å®šçš„èµ·ç‚¹
                List<Integer> nodesInPath = allPrevs(prevs, i);
                System.out.print("èµ·ç‚¹" + datas[index] + "åˆ°" + datas[i] + "ç‚¹çš„æœ€çŸ­è·¯å¾„æ˜¯: " + datas[index]);
                for (int j :nodesInPath) {
                    System.out.print("-" + matrix[prevs[j]][j] + "-" + datas[j]);
                }
                System.out.println("-" + matrix[prevs[i]][i] + "-" + datas[i] + ", è·¯å¾„æƒå€¼æ€»å’Œä¸º: " + weights[i]);
            }
        }
    }

    /**
     * æŒ‡å®šèŠ‚ç‚¹, æŒ‰è·¯å¾„é¡ºåºè¿”å›è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰å‰é©±èŠ‚ç‚¹
     *
     * @param prevs è®°å½•å‰é©±èŠ‚ç‚¹çš„æ•°ç»„
     * @param index æŒ‡å®šèŠ‚ç‚¹
     * @return java.util.List<java.lang.Integer>
     */
    private List<Integer> allPrevs(int[] prevs, int index) {
        // è®°å½•æŒ‡å®šèŠ‚ç‚¹åˆ°è¾¾æŒ‡å®šèµ·ç‚¹çš„æœ€çŸ­è·¯å¾„æ²¿é€”çš„èŠ‚ç‚¹
        Stack<Integer> prevStack = new Stack<>();
        int prev = prevs[index];
        // å‰é¢è®¾ç½®çš„ç®—æ³•æœ€å¼€å§‹æŒ‡å®šçš„èµ·ç‚¹çš„å‰é©±ç´¢å¼•ä¸º-1åœ¨è¿™é‡Œèµ·ä½œç”¨
        // åªè¦å‰é©±çš„å‰é©±ç´¢å¼•ä¸ä¸ºæœ€å¼€å§‹æŒ‡å®šçš„èµ·ç‚¹
        while (prevs[prev] != -1) {
            // æŠŠå‰é©±ç´¢å¼•åŠ å…¥æ ˆ
            prevStack.add(prev);
            // ä¸‹æ¬¡å¾ªç¯è¦æ£€æŸ¥æ­¤æ¬¡å¾ªç¯å‰é©±èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹, æ‰€ä»¥æ›´æ–°å˜é‡
            prev = prevs[prev];
        }

        // æ–¹ä¾¿éå†, å€’åºè¾“å‡º
        List<Integer> result = new ArrayList<>();
        while (!prevStack.isEmpty()) {
            result.add(prevStack.pop());
        }
        return result;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦å…¨éƒ¨è¢«éå†(åªè¦æœ‰ä¸€ä¸ªæ˜¯æœªè¢«éå†è¿”å›false)
     *
     * @return boolean
     */
    private boolean isAllVisited() {
        for (Status status : statuses) {
            if (status == Status.UNDISCOVERD) {
                return false;
            }
        }
        return true;
    }

    /**
     * æ‰¾åˆ°æ•°ç»„ä¸­æœ€å°çš„å€¼çš„ç´¢å¼•
     *
     * @return int
     */
    private int indexOfMin(int[] nums) {
        List<Integer> remain = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            if (statuses[i] == Status.UNDISCOVERD) {
                remain.add(i);
            }
        }
        if (remain.size() == 0) {
            return 0;  // è¿™é‡Œè¿”å›ä»€ä¹ˆéƒ½è¡Œ, å› ä¸ºæ‰€æœ‰èŠ‚ç‚¹ä¼šåœ¨ä¸‹ä¸€å¾ªç¯å…¨éƒ¨è®¾ç½®ä¸ºå·²è®¿é—®, ä»è€Œå¾ªç¯å†…æ— ä»»ä½•æ“ä½œ
        }
        int minIndex = remain.get(0);
        for (int j : remain) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        return minIndex;
    }

    public static void main(String[] args) {
        Graph<String> graph = new Graph<>(7);
        graph.setDatas(new String[]{"A", "B", "C", "D", "E", "F", "G"});
        int[][] matrix = {
                {0, 7, 3, 2, 2, 0, 0},
                {0, 0, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 4, 3, 0},
                {0, 0, 0, 0, 1, 10, 2},
                {0, 0, 0, 0, 0, 4, 2},
                {0, 0, 0, 0, 0, 0, 7},
                {0, 0, 0, 0, 0, 0, 0}};
        graph.setMatrix(matrix);
        graph.makeUndirected();
        for (int i = 0; i < 7; i++) {
            graph.initStatuses();
            graph.DijkstraPath(i);
        }
    }
}
```

