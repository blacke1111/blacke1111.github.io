---
title: 存储引擎
date: 2022-04-06 20:41:54
categories: mysql
---



为了管理方便，人们把**连接管理**、**查询缓存**、**语法解析**、**查询优化**这些并不涉及真实数据存储的功能划分为MysQL server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供API，获取到数据后返回给客户端就好了。
MySQL中提到了存储引擎的概念。简而言之，**存储引擎就是指表的类型**。**其实存储引擎以前叫做表处理器**，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。[

# 查看存储引擎



* 查看mysql提供的存储引擎：

  ```mysql
  show engines;
  ```

  ![image-20220406210547959](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220406210547959.png)

Transactions:事务

XA：分步式事务

Savepoints： 支持部分事务的回滚

# 设置系统默认的存储引擎

* **查看默认的存储引擎：**

  ```mysql
  show variables like '%storage_engine%';
  #或
  SELECT @@default_storage_engine;
  ```

  ![image-20220406211008266](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220406211008266.png)



* **修改默认的存储引擎**

如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用**InnoDB** 作为表的存储引擎。
如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：

```mysql
SET DEFAULT_STORAGE_ENGINE=MyISAM;
```

或者修改my.cnf 文件：

```mysql
default-storage-engine=MyISAM
# 重启服务
systemctl restart mysqld.service
```

# 设置表的存储引擎

存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是
说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

## 创建表时指定存储引擎

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎InnoDB 。如果我们想显
式的指定一下表的存储引擎，那可以这么写：

```mysql
CREATE TABLE 表名(
建表语句;
) ENGINE = 存储引擎名称;
```

## 修改表的存储引擎

如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：

```mysql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

# 引擎介绍

## **InnoDB 引擎**：具备外键支持功能的事务存储引擎

* MySQL从3.23.34a开始就包含InnoDB存储引擎。**大于等于5.5之后，默认采用InnoDB引擎**。
* InnoDB是MySQL的**默认事务型引擎**，它被设计用来处理大量的短期(short-lived)事务。可以确保事务
  的完整提交(Commit)和回滚(Rollback)。
* 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。
* **除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。**
  * 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）
  * 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）表名.ibd 存储数据和索引
* InnoDB是为处理巨大数据量的**最大性能设计**。
  * 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。
* 对比MyISAM的存储引擎， **InnoDB写的处理效率差一些**，并且会占用更多的磁盘空间以保存数据和索引。
* MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， **对内存要求较高**，而且内存大小对性能有决定性的影响。

## **MyISAM 引擎**：主要的非事务处理存储引擎

* MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级锁、外键，**有一个毫无疑问的缺陷就是崩溃后无法安全恢复。**
* **5.5之前默认的存储引擎**
* **优势是访问的速度快**，对事务完整性没有要求或者以SELECT、INSERT为主的应用
* 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高
* 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）
  * 表名.frm 存储表结构
  * 表名.MYD 存储数据 (MYData)
  * 表名.MYI 存储索引 (MYIndex)
* 应用场景：只读应用或者以读为主的业务

## MyISAM和InnoDB

很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？
MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。

![image-20220406213343465](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220406213343465.png)

## Archive 引擎：用于数据存档

![image-20220406214110843](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220406214110843.png)

![image-20220406213756925](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220406213756925.png)

## Blackhole 引擎：丢弃写操作，读操作会返回空内容

* Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。
* 但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。

## CSV 引擎：存储数据时，以逗号分隔各个数据项

* CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。
* CSV引擎可以作为一种数据交换的机制，非常有用。
* CSV存储的数据直接可以在操作系统(自己电脑)里，用文本编辑器，或者excel读取。
* 对于数据的快速导入、导出是有明显优势的。

## Memory 引擎：置于内存中数据的表

概述：
Memory采用的逻辑介质是内存， **响应速度很快**，但是当mysqld守护进程崩溃的时候数据会丢失。另
外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。

主要特征：

* Memory同时支持哈希（HASH）索引和B+树索引。
  * 哈希索引相等的比较快，但是对于范围的比较慢很多。
  * **默认使用哈希（HASH）索引**，其速度要比使用B型树（BTREE)索引快。。
  * 如果希望使用B树索引，可以在创建索引时选择使用。

* Memory表至少比MyISAM表要快一个数量级。
* MEMORY 表的**大小是受到限制的**。表的大小主要取决于两个参数，分别是max_rows 和max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。
* 数据文件与索引文件分开存储。
* 缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。

**使用Memory存储引擎的场景：**

1. 目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大小。
2. 如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。

3. 存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。

## Federated 引擎：访问远程表

* Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的**跨服务器的灵活性**，但也经常带来问题，因此默认是禁用的。

## Merge引擎：管理多个MyISAM表构成的表集合

## NDB引擎：MySQL集群专用存储引擎

也叫做 NDB Cluster 存储引擎，主要用于 **MySQL Cluster** 分布式集群环境，类似于 Oracle 的 **RAC 集**
**群。**

# InnoDB表的优势

InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。

在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被
自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。**InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。**

InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以在**不影响性能和可用性的情况下创建或删除索引**。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。**当处理大数据量时，InnoDB兼顾CPU，以达到最大性能**。
