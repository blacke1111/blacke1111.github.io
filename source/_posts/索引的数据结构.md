---
title: 索引的数据结构
date: 2022-04-08 19:29:41
categories: mysql
---

# 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image-20220408194050795](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408194050795.png)

![image-20220408194056262](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408194056262.png)

对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是（K，V)结构，key是Col 2， value是该key所在行的文件指针（地址)。比如:该二叉搜索树的根节点就是: (34,0x07)。现在对Col 2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89>34;继续右侧数据，读89到内存，89 == 89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。
这就是我们为什么要建索引，目的就是为了**减少磁盘I/O的次数**，加快查询速率。

# 索引及其优缺点

## 索引概述

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
**索引的本质**：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现**高级查找算法**。

**索引是在存储引擎中实现的**，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

## 优点

​	(1)类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主
要的原因。 

（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 

（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，
可以提高查询速度。 

（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时
间，降低了CPU的消耗。

## 缺点:

增加索引也有许多不利的方面，主要表现在如下几个方面： 

（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 

（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。

 （3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示:
> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。

# InnoDB中索引的推演

## 索引之前的查找

先来看一个精确匹配的例子：

```mysql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```



## 在一个页中查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:

* 以主键为搜索条件
  可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
* 以其他列作为搜索条件
  因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单键表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。|

## 在很多页中查找

1:定位到记录所在的页

2: 从所在的页内中查找相应的记录

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录
所在的页，所以只能从**第一个页**沿着双向链表**一直往下找**，在每一个页中根据我们上面的查找方式去查
找指定的记录。因为要遍历所有的数据页，所以这种方式显然是**超级耗时**的。如果一个表有一亿条记录
呢？此时**索引**应运而生。

## 设计索引

建一个表：

```mysql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```

这个新建的index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，
这个表使用Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：



![image-20220408201138880](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408201138880.png)

我们只在示意图里展示记录的这几个部分：

* record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、2 表示最小记录、3 表示最大记录、1 暂时还没用过，下面讲。

* next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。

* 各个列的值：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3 。

* 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

  将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

  ![image-20220408201313665](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408201313665.png)

  把一些记录放到页里的示意图就是：

  ![image-20220408201326909](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408201326909.png)

### 一个简单的索引设计方案



我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：

* 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键

  

* 给所有的页建立一个目录项

  因为这些16KB的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分:
  。页的用户记录中最小的主键值，我们用key来表示。
  。页号，我们用page_no表示。

* 所以我们为上边几个页做好的目录就像这样子：

![image-20220408201418080](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408201418080.png)

以页28 为例，它对应目录项2 ，这个目录项中包含着该页的页号28 以及该页中用户记录的最小主键值5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20 的记录，具体查找过程分两步：

1. 先从目录项中根据二分法快速确定出主键值为20 的记录在目录项3 中（因为 12 < 20 <209 ），它对应的页是页9 。
2. 再根据前边说的在页中查找记录的方式去页9 中定位具体的记录。

**至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。**

### InnoDB中的索引方案

#### 迭代1次：目录项纪录的页

上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上**连续存储**，但是这样做有几个问题:

* InnoDB是使用页来作为管理存储空间的基本单位，最多能保证16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。

* 我们时常会对记录进行增删，假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。

所以，我们需要一种可以**灵活管理所有目录项**的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB怎么区分一条记录是普通的用户记录还是目录项记录呢?使用记录头信息里的
record_type属性，它的各个取值代表的意思如下:

* 0:普通的用户记录
*  1:目录项记录 
* 2∶最小记录
* 3:最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![image-20220408202007982](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408202007982.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调**目录项记录**和**普通的用户记录**的

不同点：

* 目录项记录的record_type 值是1，而普通用户记录的record_type 值是0。
* 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很**多列**，另外还有InnoDB自己添加的隐藏列。
* 了解：记录头信息里还有一个叫min_rec_mask 的属性，只有在存储目录项记录的页中的主键值
  最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。

相同点:两者用的是一样的数据页，都会为主键值生成Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

现在以查找主键为20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：
1. 先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 < 20 <209 ，所以定位到对应的记录所在的页就是页9。
2. 再到存储用户记录的页9中根据二分法快速定位到主键值为20 的用户记录。

#### 迭代2次：多个目录项纪录的页

虽然说**目录项记录**中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的**目录项记录**也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，**如何处理呢**?
这里我们假设一个存储目录项记录的页最多**只能存放4条目录项记录**，所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页:

![](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/20220408203610.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

* 为存储该用户记录而新生成了页31 。

* 因为原先存储目录项记录的页30的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的页32 来存放页31 对应的目录项。


现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20 的记录为例：

1. 确定目录项记录页
我们现在的存储目录项记录的页有两个，即页30 和页32 ，又因为页30表示的目录项的主键值的
范围是[1, 320) ，页32表示的目录项的主键值不小于320 ，所以主键值为20 的记录对应的目
录项记录在页30 中。
2. 通过目录项记录页确定用户记录真实所在的页。
在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。
3. 在真实存储用户记录的页中定位到具体的记录。

#### 迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢?那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子:

![](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/20220408203549.png)

如图，我们生成了一个存储更高级目录项的页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值不小于320 的话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：

![image-20220408204008951](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408204008951.png)

这个数据结构，它的名称是B+树。

**B+Tree**:

**一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第0 层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

* 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100 条记录。
* 如果B+树有2层，最多能存放1000×100=10,0000 条记录。
* 如果B+树有3层，最多能存放1000×1000×100=1,0000,0000 条记录。
* 如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！！！

你的表里能存放**100000000000** 条记录吗？所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory （页目录），所以在页面内也可以通过**二分法**实现快速定位记录。

## 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。

### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是所谓的索引即**数据，数据即索引。**

> 术语"聚簇"表示数据行和相邻的键值聚簇的存储在一起。 就是数据和索引就是存储在一起的

**特点：**

1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

* 页内的记录是按照主键的大小顺序排成一个单向链表。
* 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
* 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2.B+树的叶子节点存储的是完整的用户记录。
所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为**聚簇索引**，所有完整的用户记录都存放在这个**聚簇索引**的叶子节点处。这种聚簇索引并不需要我们在MysQL语句中显式的使用**INDEX**语句去创建,**InnoDB**存储引擎会自动的为我们创建聚簇索引。

**优点：**

* **数据访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
* 聚簇索引对于主键的**排序查找**和**范围查找**速度非常快
* 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连**，数据库不用从多个数据块中提取数据，所以节省了大量的io操作**。

**缺点：**

* **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
* **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新
* **二级索引访问需要两次索引查找**，第一次找到主键值，第二次根据主键值找到行数据

**限制:**

* 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。
* 由于数据物理存储排序方式只能有一种，所以每个MysQL的表只能有一个聚簇索引。一般情况下就是该表的主键。
* 如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。|
* 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

###  二级索引（辅助索引、非聚簇索引）

![image-20220408210302868](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408210302868.png)

概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2 棵B+树！

**问题：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？**

![image-20220408210455540](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408210455540.png)

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按
照c2和c3列的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照c2列进行排序。
* 在记录的c2列相同的情况下，采用c3列进行排序

注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

* 建立联合索引只会建立如上图一样的1棵B+树。
* 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。



## InnoDB的B+树索引的注意事项

### 根页面位置万年不动

我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:

* 每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个
  根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。

* 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。

* 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到页a或者b中，而根节点便升级为存储目录项记录的页。



这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引l的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

### 内节点中目录项记录的唯一性

目录项记录的索引列要唯一， 如果对应的目录项索引一致时，构建目录项时要加上主键值。



### 一个页面最少存储2条记录

# MyISAM中的索引方案

**B树索引适用存储引擎如表所示：**

![image-20220408212918408](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408212918408.png)



即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。
MyISAM引擎使用B+Tree 作为索引结构，叶子节点的data域存放的是**数据记录的地址**。

## MyISAM索引的原理

下图是MyISAM索引的原理图。
我们知道**InnoDB中索引即数据**，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而**MyISAM**的索引方案虽然也使用树形结构，但是却**将索引和数据分开存储**︰

* 将表中的记录**按照记录的插入顺序单独存储在一个文件中**，称之为数据文件，这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。
* 使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值＋数据记录地址的组合。



![image-20220408213431038](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408213431038.png)

如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：

在构建叶子节点的时候是要按照数据进行排序的（如下图）

![image-20220408213603370](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408213603370.png)

## MyISAM 与 InnoDB对比

**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：**
① 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次**回表**操作，意味着MyISAM中建立的索引相当于全部都是**二级索引**。
② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是**分离的**，索引文件仅保存数据记录的地址。
③ InnoDB的非聚簇索引data域存储相应记录**主键的值**，而MyISAM索引记录的是**地址**。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。
④ MyISAM的回表操作是十分**快速**的，因为是拿着地址偏移量直接到文件中取数据的，**反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。**
⑤ InnoDB要求表**必须有主键（ MyISAM可以没有）**。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

![image-20220408213853597](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220408213853597.png)

## 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

* 空间上的代价
  每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，**一个页默认会**
  **占用16KB 的存储空间**，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

* 时间上的代价

  每次对表中的数据进行**增、删、改**操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值**从小到大的顺序排序**而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

# MySQL数据结构选择的合理性

从MysQL的角度讲，不得不考虑一个现实问题就是磁盘to。如果我们能让索引的数据结构尽量减少硬盘的I/o操作，所消耗的时间也就越小。可以说，磁盘的 I/O操作次数对索引的使用效率至关重要。
查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MySQL衡量查询效率的标准就是磁盘IO次数。 



## 全表遍历



## Hash结构

![image-20220409194514590](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409194514590.png)

Hash结构效率高，那为什么索引结构要设计成树型呢？

原因1: Hash索引仅能满足(=)(<>)和IN查询。如果进行**范围查询**，哈希型的索引，时间复杂度会退化为o(n);而树型的“有序”特性，依然能够保持o(log2N)的高效率。
原因2: Hash 索引还有一个缺陷，数据的存储是**没有顺序的**，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。Ⅰ
原因3∶对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。
原因4:∶对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是**索引列的重复值如果很多，效率就会降低**。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以,Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。

![image-20220409194945460](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409194945460.png)



**hash索引的自适应性**

![image-20220409195447973](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409195447973.png)

采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。
我们可以通过innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：

```mysql
mysql> show variables like '%adaptive_hash_index';
```

![image-20220409195535804](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409195535804.png)

## 二叉搜索树

如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。

我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:
1.如果key大于根节点，则在右子树中进行查找;

2.如果key小于根节点，则在左子树中进行查找;

3.如果key等于根节点，也就是找到了这个节点，返回根节点即可。
举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:

![image-20220409195734996](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409195734996.png)

但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是(5, 22,23,34,77,89,91),创造出来的二分搜索树如下图所示：

![image-20220409195743502](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409195743502.png)

为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好

## AVL树

为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树（Balanced Binary Ttree),
AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:
**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**
这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉树、红黑树、数堆，伸展树，平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树，事实上，第一棵树就属于平衡二叉树就属于平衡二叉搜索树，搜索时间复杂度就是0( log2n)。
数据查询的时间主要依赖于磁盘l/o的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是o(log2n)，当n 比较大时，深度也是比较高的，比如下图的情况:

![image-20220409200244364](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409200244364.png)

## B-Tree

B 树的结构如下图所示：

![image-20220409200657367](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409200657367.png)

一个 M 阶的 B 树（M>2）有以下的特性：
1. 根节点的儿子数的范围是 [2,M]。
2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为
[ceil(M/2), M]。
3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。
4. 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]
    <Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。

5. 所有叶子节点位于同一层。
上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。然后我们来看下如何用 B 树进行查找。假设我们想要查找的关键字是 9 ，那么步骤可以分为以下几步：
1. 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；
2. 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；
3. 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。
你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。B 树相比于平衡二叉树来说磁盘 I/O 操作要少，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少，就可以提高查询性能。

再举例：

![image-20220409200813998](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409200813998.png)



## B+Tree

B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，B+Tree适合文件索引系统。|

MySQL官网说明：

![image-20220409200948975](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409200948975.png)

**B+ 树和 B 树的差异：**

1. 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。

2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， **非叶子节点既保存索引，也保存数据记录。**
4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。



首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。
其次，**B+树的查询效率更高**。这是因为通常B+树比B树**更矮胖**(阶数更大，深度更低)，查询所需要的磁盘I/o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。意思就就是 b+树数据都保存在叶子节点中，这样比b树的数据分步在各个节点中 ，b+树 目录页就拥有了更多的目录项，就可以使我们的b+树变得更矮更胖 ，以减少io的次数
不仅是对单个关键字的查询上，在查询范围上，**B+树的效率也比B树高**。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通讨中序遍历才能完成杳询范围的杳找，效率要低很多。

**思考题：为了减少IO，索引树会一次性加载吗？**

![image-20220409202450753](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409202450753.png)

**思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO**

![image-20220409202608913](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409202608913.png)

**思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？**

![image-20220409203008634](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409203008634.png)

**思考题：Hash 索引与 B+ 树索引的区别**

1、Hash 索引**不能进行范围查询**，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。
2、Hash索引不支持联合索引的**最左侧原则**（(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。|
3、HasW索引**不支持ORDER BY排序**，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（(比如%结尾）的话就可以起到优化作用。

4.InnonDB 不支持哈希索引

**思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？**

InnonDB 和MyISAM不支持hash索引，但是InnonDb可以有自适应Hash索引并且不需要手动指定，而且默认开启

## R树

R-Tree在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R树就很好的解决了这种高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。相对于B-Tree，R-Tree的优势在于范围查找。

![image-20220409203722429](https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220409203722429.png)
