<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="zhy, NexT" />










<meta name="description" content="都有哪些维度可以进行数据库调优?简言之:  索引失效、没有充分利用到索引——索引建立 关联查询太多JOIN(设计缺陷或不得已的需求)——SQL优化 服务器调优及各个参数设置（缓冲、线程数等)—―调整my.cnf 数据过多—―分库分表  关于数据库调优的知识点非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。 虽然SQL查询优化的技术">
<meta property="og:type" content="article">
<meta property="og:title" content="索引优化与查询优化">
<meta property="og:url" content="https://zhanghaoyu0724.github.io/2022/04/13/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="蓝天の博客">
<meta property="og:description" content="都有哪些维度可以进行数据库调优?简言之:  索引失效、没有充分利用到索引——索引建立 关联查询太多JOIN(设计缺陷或不得已的需求)——SQL优化 服务器调优及各个参数设置（缓冲、线程数等)—―调整my.cnf 数据过多—―分库分表  关于数据库调优的知识点非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。 虽然SQL查询优化的技术">
<meta property="og:locale">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413152925723.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413153215446.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413153254470.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154223517.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154733224.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154742378.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413160731934.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413161733630.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413161618653.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413163827141.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164338608.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164745136.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164855811.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165044049.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165347782.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165426218.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413170925911.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171024976.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171312212.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171329319.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171942800.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171951280.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413173913094.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414213302723.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414214200197.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414214219796.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414224722266.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414224734281.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222806887.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222812172.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222859129.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222904548.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416130752363.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416130855353.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416131118897.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132130053.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132320362.png">
<meta property="og:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132339362.png">
<meta property="article:published_time" content="2022-04-13T06:53:13.000Z">
<meta property="article:modified_time" content="2024-04-06T11:46:12.373Z">
<meta property="article:author" content="Zhang Hao Hu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413152925723.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":8,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhanghaoyu0724.github.io/2022/04/13/索引优化与查询优化/"/>





  <title>索引优化与查询优化 | 蓝天の博客</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝天の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhanghaoyu0724.github.io/2022/04/13/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张浩宇">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝天の博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">索引优化与查询优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-13T14:53:13+08:00">
                2022-04-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-04-06T19:46:12+08:00">
                2024-04-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  48
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>都有哪些维度可以进行数据库调优?简言之:</p>
<ul>
<li>索引失效、没有充分利用到索引——索引建立</li>
<li>关联查询太多JOIN(设计缺陷或不得已的需求)——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等)—―调整my.cnf</li>
<li>数据过多—―分库分表</li>
</ul>
<p>关于数据库调优的知识点非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。<br>
虽然SQL查询优化的技术有很多，但是大方向上完全可以分成物理查询优化和逻辑查询优化两大块。</p>
<ul>
<li>
<p>物理查询优化是通过<strong>索引</strong>和<strong>表连接</strong>方式等技术来进行优化，这里重点需要掌握索引的使用。</p>
</li>
<li>
<p>逻辑查询优化就是通过SQL<strong>等价变换</strong>提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</p>
</li>
</ul>
<h1>数据准备</h1>
<p>学员表插50万条， 班级表插1万条。</p>
<p>步骤1：建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `class` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`className` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">`address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">`monitor` INT NULL ,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">#CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>步骤2：设置参数</p>
<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<p>步骤3：创建函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#随机产生字符串</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">WHILE i &lt; n DO</span><br><span class="line">SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_string;</span><br></pre></td></tr></table></figure>
<p>随机产生班级编号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_num;</span><br></pre></td></tr></table></figure>
<p>步骤4：创建存储过程</p>
<p>创建往stu表中插入数据的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建往stu表中插入数据的存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student (stuno, name ,age ,classId ) VALUES</span><br><span class="line">((START+i),rand_string(6),rand_num(1,50),rand_num(1,1000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_stu;</span><br></pre></td></tr></table></figure>
<p>创建往class表中插入数据的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加随机数据</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `insert_class`( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO class ( classname,address,monitor ) VALUES</span><br><span class="line">(rand_string(8),rand_string(10),rand_num(1,100000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_class;</span><br></pre></td></tr></table></figure>
<p>步骤5：调用存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加1万条数据</span><br><span class="line">CALL insert_class(10000);</span><br><span class="line">#执行存储过程，往stu表添加50万条数据</span><br><span class="line">CALL insert_stu(100000,500000);</span><br></pre></td></tr></table></figure>
<p>步骤6：删除某表上的索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE done INT DEFAULT 0;</span><br><span class="line">DECLARE ct INT DEFAULT 0;</span><br><span class="line">DECLARE _index VARCHAR(200) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE _cur CURSOR FOR SELECT index_name FROM</span><br><span class="line">information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND</span><br><span class="line">seq_in_index=1 AND index_name &lt;&gt;&#x27;PRIMARY&#x27; ;</span><br><span class="line">#每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;</span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为2</span><br><span class="line">OPEN _cur;</span><br><span class="line">FETCH _cur INTO _index;</span><br><span class="line">WHILE _index&lt;&gt;&#x27;&#x27; DO</span><br><span class="line">SET @str = CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename );</span><br><span class="line">PREPARE sql_str FROM @str ;</span><br><span class="line">EXECUTE sql_str;</span><br><span class="line">DEALLOCATE PREPARE sql_str;</span><br><span class="line">SET _index=&#x27;&#x27;;</span><br><span class="line">FETCH _cur INTO _index;</span><br><span class="line">END WHILE;</span><br><span class="line">CLOSE _cur;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#执行存储过程</span><br><span class="line">CALL proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure>
<h1>索引失效案例</h1>
<p>MysQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<ul>
<li>
<p>使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</p>
</li>
<li>
<p>如果查询时没有使用索引，查询语句就会<strong>扫描表中的所有记录</strong>。在数据量大的情况下，这样查询的速度会很慢。</p>
</li>
</ul>
<p>大多数情况下都（默认）采用<strong>B+树</strong>来构建索引。只是空间列类型的索引使用<strong>R-树</strong>，并且MEMORY表还支持<strong>hash索引</strong>。</p>
<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器?基于<strong>cost开销(CostBaseOptimizer )</strong>，它不是基于<strong>规则(Rule-BasedOptimizer)</strong>，也不是基于语义。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p>
<h2 id="全值匹配我最爱">全值匹配我最爱</h2>
<p>系统中经常出现的sql语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND NAME=&#x27;abcd&#x27;</span><br></pre></td></tr></table></figure>
<p>简历索引前执行:(关注执行时间)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE  * FROM student WHERE age=30 AND classId=4 AND NAME=&#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413152925723.png" alt="image-20220413152925723"></p>
<p>建立索引:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age ON student(age);</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_age_classId ON student(age,classId)</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_age_classId_name ON student(age,classId,NAME)</span><br></pre></td></tr></table></figure>
<p>执行sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND NAME=&#x27;abcd&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到我们的而查询语句使用到了索引</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413153215446.png" alt="image-20220413153215446"></p>
<p>时间：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413153254470.png" alt="image-20220413153254470"></p>
<h2 id="最佳左前缀原则">最佳左前缀原则</h2>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154223517.png" alt="image-20220413154223517"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND NAME=&#x27;abcd&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE classId=1 AND NAME=&#x27;abcd&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE classId=30 AND age=30 AND NAME=&#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p>结论:MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第1个字段时，多列(或联合）索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》<br>
索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h2 id="主键插入顺序">主键插入顺序</h2>
<p>对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录<strong>主键值从小到大的顺序进行排序</strong>，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<strong>主键值忽大忽小</strong>的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在1~100之间:</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154733224.png" alt="image-20220413154733224"></p>
<p>如果此时再插入一条主键值为9 的记录，那它插入的位置就如下图：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413154742378.png" alt="image-20220413154742378"></p>
<p>可这个数据页已经满了，再插进来咋办呢?我们需要把当前<strong>页面分裂</strong>成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么?意味着:性能损耗!所以如果我们想尽量避免这样无谓的<strong>性能损耗</strong>，最好让插入的记录的<strong>主键值依次递增</strong>，这样就不会发生这样的性能损耗了。所以我们建议:让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入，比如: person_info表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(100) NOT NULL,</span><br><span class="line">birthday DATE NOT NULL,</span><br><span class="line">phone_number CHAR(11) NOT NULL,</span><br><span class="line">country varchar(100) NOT NULL,</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们自定义的主键列id 拥有<strong>AUTO_INCREMENT</strong> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h2 id="计算、函数、类型转换-自动或手动-导致索引失效">计算、函数、类型转换(自动或手动)导致索引失效</h2>
<p>下面拆查询效果一样，但是第一条比第二条好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#取出 student.name的前三个字符 是不是abc 来比较 要取出所有的student.name 所以使用不上索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>student表的字段stuno上设置有索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_sno ON student(stuno);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#没有使用上索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用了索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id ,stuno,NAME FROM student WHERE stuno=900000</span><br></pre></td></tr></table></figure>
<ul>
<li>student表的字段name上设置有索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#显然没有使用上索引</span><br><span class="line">EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)=&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用了索引</span><br><span class="line">EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换导致索引失效">类型转换导致索引失效</h2>
<p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="范围条件右边的列索引失效">范围条件右边的列索引失效</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX idx_name;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age_classid;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413160731934.png" alt="image-20220413160731934"></p>
<p><strong>student.classId的范围查找导致name索引没有使用上，key_len只有10</strong></p>
<p>如何解决:</p>
<p><strong>建立索引时把等值条件的放在左边</strong> ，不用管查询语句的等值条件和范围条件顺序，只需要保障联合索引的中范围条件在等值条件的右边</p>
<h2 id="不等于-或者-索引失效">不等于(!= 或者&lt;&gt;)索引失效</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME)</span><br><span class="line">#可以用上idx_name索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name =&#x27;abc&#x27;</span><br><span class="line">#不可以用上idx_name索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="is-null可以使用索引，is-not-null无法使用索引">is null可以使用索引，is not null无法使用索引</h2>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413161733630.png" alt="image-20220413161733630"></p>
<h2 id="like以通配符-开头索引失效">like以通配符%开头索引失效</h2>
<p>原因: 我们一开始就不知道从那个字符开始 都不知道怎么查找，还不如全表查找 主要原因开头无法确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIAIN SELECT SQL NO_CACHE* FROM student WHERE NAME LIKE &#x27;ab% &#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413161618653.png" alt="image-20220413161618653"></p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》<br>
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</blockquote>
<h2 id="OR-前后存在非索引的列，索引失效">OR 前后存在非索引的列，索引失效</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="数据库和表的字符集统一使用utf8mb4">数据库和表的字符集统一使用utf8mb4</h2>
<p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<strong>字符集</strong>进行比较前需要进行转换会造成索引失效。</p>
<p>一般性建议:</p>
<ul>
<li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<h1>关联查询优化</h1>
<h2 id="数据准备-3">数据准备</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `type`(</span><br><span class="line">	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `book`(</span><br><span class="line">	`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">	PRIMARY KEY(`bookid`)</span><br><span class="line">)</span><br><span class="line">#在每个表添加20条数据</span><br><span class="line">INSERT INTO TYPE(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line"></span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>
<h2 id="采用左外连接">采用左外连接</h2>
<p>下面开始 EXPLAIN 分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413163827141.png" alt="image-20220413163827141"></p>
<p>添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_card ON book(card)</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164338608.png" alt="image-20220413164338608"></p>
<p>如果只能添加一个索引 优先添加在被驱动表</p>
<p>注意：多表连接判断的字段要一样，不然会出现索引失效的时候</p>
<h2 id="采用内连接">采用内连接</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#先删除索引</span><br><span class="line">DROP INDEX idx_card ON book</span><br></pre></td></tr></table></figure>
<p>换成 inner join（MySQL自动选择驱动表）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164745136.png" alt="image-20220413164745136"></p>
<p>添加索引:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index Y on book(card)</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413164855811.png" alt="image-20220413164855811"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create index X on type(card)</span><br><span class="line">#对于内连接来说，查询优化器可以决定谁作为驱动表和被驱动表出现的</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165044049.png" alt="image-20220413165044049"></p>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX X ON `type`;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165347782.png" alt="image-20220413165347782"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `type` ADD INDEX X (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413165426218.png" alt="image-20220413165426218"></p>
<p>小结：</p>
<p>结论:</p>
<p>1.对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动出现</p>
<p>2.对于内连接来讲，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。&quot;小表驱动大表</p>
<h2 id="join语句原理">join语句原理</h2>
<p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是<strong>嵌套循环(Nested Loop Join)</strong>。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5<br>
以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
<h3 id="驱动表和被驱动表"><strong>驱动表和被驱动表</strong></h3>
<p>驱动表就是主表,被驱动表就是从表，非驱动表</p>
<ul>
<li>
<p>对于内连接来说:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A join b on ...</span><br></pre></td></tr></table></figure>
<p>A一定是驱动表吗?不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。|</p>
</li>
<li>
<p>对于外连接来说:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A left join b on ...</span><br></pre></td></tr></table></figure>
<p>也不一定是A作为驱动表，b作为被驱动表</p>
<p>案例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE a(f1 INT , f2 INT, INDEX(f1));</span><br><span class="line"></span><br><span class="line">CREATE TABLE b(f1 INT , f2 INT )</span><br><span class="line"></span><br><span class="line">INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6)</span><br><span class="line"></span><br><span class="line">INSERT INTO b VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6)</span><br><span class="line">#a作为被驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON a.f1=b.f1 WHERE a.f2=b.f2</span><br><span class="line">#查看查询优化器改造后的sql、 变成了内连接</span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigudb2`.`a`.`f1` AS `f1`,`atguigudb2`.`a`.`f2` AS `f2`,`atguigudb2`.`b`.`f1` AS `f1`,`atguigudb2`.`b`.`f2` AS `f2` from `atguigudb2`.`a` join `atguigudb2`.`b` where ((`atguigudb2`.`a`.`f1` = `atguigudb2`.`b`.`f1`) and (`atguigudb2`.`a`.`f2` = `atguigudb2`.`b`.`f2`))</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#a作为驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON a.f1=b.f1 AND a.f2=b.f2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Simple-Nested-Loop-Join-简单嵌套循环连接">Simple Nested-Loop Join(简单嵌套循环连接)</h3>
<p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result…以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断:</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413170925911.png" alt="image-20220413170925911"></p>
<p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B= 10万次。开销统计如下:</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171024976.png" alt="image-20220413171024976"></p>
<p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p>
<h3 id="Index-Nested-Loop-Join（索引嵌套循环连接）">Index Nested-Loop Join（索引嵌套循环连接）</h3>
<p>Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171312212.png" alt="image-20220413171312212"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表)。</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171329319.png" alt="image-20220413171329319"></p>
<p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<h3 id="Block-Nested-Loop-Join-块嵌套循环连接">Block Nested-Loop Join(块嵌套循环连接)</h3>
<p>如果存在索引，那么会使用index的方式进行join，<strong>如果join的列没有索引</strong>，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了I0的次数。为了减少被驱动表的Io次数，就出现了Block Nested-Loop Join的方式。<br>
不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列(大小受join buffer的限制)缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<blockquote>
<p>注意:<br>
这里缓存的不只是关联表的列,select后面的列也会缓存起来。<br>
在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让joinbuffer中可以存放更多的列。</p>
</blockquote>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171942800.png" alt="image-20220413171942800"></p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413171951280.png" alt="image-20220413171951280"></p>
<p>参数设置：</p>
<ul>
<li>block_nested_loop</li>
</ul>
<p>通过<strong>show variables like ‘%optimizer_switch%’</strong> 查看block_nested_loop状态，默认开启.</p>
<ul>
<li>join_buffer</li>
</ul>
<p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size=256。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%join_buffer%&#x27;;</span><br></pre></td></tr></table></figure>
<p>join_buffer_size的最大值在32位系统可以申请4G，而在64位操做系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告)。</p>
<h2 id="Join小结：">Join小结：</h2>
<p>1.整体效率:INLJ&gt;BNLJ&gt;SNLJ</p>
<p>2、永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量)(小的度量单位指的是表行数*每行大小)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#straight_join不让查询优化器来破坏顺序</span><br><span class="line">select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;#推荐</span><br><span class="line"></span><br><span class="line">select t1.b, t2.* from t2 straight_join t1Ton (t1.b=t2.b) where t2.id&lt;=100;#不推荐</span><br></pre></td></tr></table></figure>
<p>3、为被驱动表匹配的条件增加索引(减少内层表的循环匹配次数)<br>
4、增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫表次数就越少)<br>
5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多)</p>
<h2 id="Hash-join">Hash join</h2>
<p>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</p>
<ul>
<li>Nested Loop:<br>
对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</li>
<li>Hash Join是做<strong>大数据集连接</strong>时的常用方式，优化器使用两个表中较小(相对较小）的表利用Join Key在内存中建立<strong>散列表</strong>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。
<ul>
<li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。|</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接(如WHERE A.COL1 =B.COL2)，这是由Hash的特点决定的。</li>
</ul>
</li>
</ul>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220413173913094.png" alt="image-20220413173913094"></p>
<h1>子查询优化</h1>
<p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。<strong>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。</strong><br>
<strong>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</strong><br>
① 执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表<br>
中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。<br>
② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会<br>
受到一定的影响。<br>
③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。<br>
在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
<h2 id="排序优化">排序优化</h2>
<p>问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p>
<p>优化建议：</p>
<ol>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，在 ORDER BY 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>
<h3 id="案例实战">案例实战</h3>
<p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。<br>
执行案例前先清除student上的索引，只留主键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age ON student;</span><br><span class="line">DROP INDEX idx_age_classid_stuno ON student;</span><br><span class="line">DROP INDEX idx_age_classid_name ON student;</span><br><span class="line">#或者</span><br><span class="line">call proc_drop_index(&#x27;atguigudb2&#x27;,&#x27;student&#x27;);</span><br></pre></td></tr></table></figure>
<p>场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414213302723.png" alt="image-20220414213302723"></p>
<p>查询结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY</span><br><span class="line">NAME ;</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">| 922 | 100923 | elTLXD | 30 | 249 |</span><br><span class="line">| 3723263 | 100412 | hKcjLb | 30 | 59 |</span><br><span class="line">| 3724152 | 100827 | iHLJmh | 30 | 387 |</span><br><span class="line">| 3724030 | 100776 | LgxWoD | 30 | 253 |</span><br><span class="line">| 30 | 100031 | LZMOIa | 30 | 97 |</span><br><span class="line">| 3722887 | 100237 | QzbJdx | 30 | 440 |</span><br><span class="line">| 609 | 100610 | vbRimN | 30 | 481 |</span><br><span class="line">| 139 | 100140 | ZqFbuR | 30 | 351 |</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">8 rows in set, 1 warning (3.16 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须<br>
的。</p>
</blockquote>
<p>优化思路：</p>
<p>方案一: 为了去掉filesort我们可以把索引建成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建新索引</span><br><span class="line">CREATE INDEX idx_age_name ON student(age,NAME);</span><br></pre></td></tr></table></figure>
<p>方案二: 尽量让where的过滤条件和排序使用上索引</p>
<p>建一个三个字段的组合索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age_name ON student;</span><br><span class="line">CREATE INDEX idx_age_stuno_name ON student (age,stuno,NAME);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| 167 | 100168 | AClxEF | 30 | 319 |</span><br><span class="line">| 323 | 100324 | bwbTpQ | 30 | 654 |</span><br><span class="line">| 651 | 100652 | DRwIac | 30 | 997 |</span><br><span class="line">| 517 | 100518 | HNSYqJ | 30 | 256 |</span><br><span class="line">| 344 | 100345 | JuepiX | 30 | 329 |</span><br><span class="line">| 905 | 100906 | JuWALd | 30 | 892 |</span><br><span class="line">| 574 | 100575 | kbyqjX | 30 | 260 |</span><br><span class="line">| 703 | 100704 | KJbprS | 30 | 594 |</span><br><span class="line">| 723 | 100724 | OTdJkY | 30 | 236 |</span><br><span class="line">| 656 | 100657 | Pfgqmj | 30 | 600 |</span><br><span class="line">| 982 | 100983 | qywLqw | 30 | 837 |</span><br><span class="line">| 468 | 100469 | sLEKQW | 30 | 346 |</span><br><span class="line">| 988 | 100989 | UBYqJl | 30 | 457 |</span><br><span class="line">| 173 | 100174 | UltkTN | 30 | 830 |</span><br><span class="line">| 332 | 100333 | YjWiZw | 30 | 824 |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>结果竟然有 filesort的 sql 运行速度， 超过了已经优化掉 filesort的 sql ，而且快了很多，几乎一瞬间就出现了结果</p>
<p>结论：</p>
<ol>
<li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择<br>
idx_age_stuno_name）。但是， 随着数据量的变化，选择的索引也会随之变化的。</li>
<li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过<br>
滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段<br>
上。反之，亦然。</li>
</ol>
<h3 id="filesort算法：双路排序和单路排序">filesort算法：双路排序和单路排序</h3>
<p><strong>双路排序 （慢）</strong></p>
<ul>
<li>
<p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p>
</li>
<li>
<p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p>
</li>
</ul>
<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种<br>
改进的算法，就是单路排序。<br>
<strong>单路排序 （快）</strong><br>
从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空 间， 因为它把每一行都保存在内存中了。<br>
结论及引申出的问题</p>
<ul>
<li>由于单路是后出的，总体而言好过双路</li>
<li>但是用单路有问题
<ul>
<li>在sort_buffer中，单路比多路要<strong>多占用很多空间</strong>，因为单路是把所有字段都取出,所以有可能取出的数据的总大小超出了<strong>sort_buffer</strong>的容量，导致每次只能取sort_buffer容量大小的数据，进行排序创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排…从而多次I/O。</li>
<li>单路本来想省一次I/o操作，<strong>反而导致了大量的I/0操作</strong>，反而得不偿失。</li>
</ul>
</li>
</ul>
<p>优化策略</p>
<ol>
<li>尝试提高 sort_buffer_size</li>
<li>尝试提高 max_length_for_sort_data</li>
<li>Order by 时select * 是一个大忌。最好只Query需要的字段。</li>
</ol>
<p>GROUP BY优化</p>
<ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>当无法使用索引列，增大max_length_for_sort_data 和sort_buffer_size 参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、groupby、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行<br>
以内，否则SQL会很慢。</li>
</ul>
<h1>优化分页查询</h1>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是limit 2000000,10，此时需要MysQL排序前2000010记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 2000800, 10 ;</span><br></pre></td></tr></table></figure>
<h2 id="优化思路一">优化思路一</h2>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414214200197.png" alt="image-20220414214200197"></p>
<h2 id="优化思路二">优化思路二</h2>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414214219796.png" alt="image-20220414214219796"></p>
<h1>优先考虑覆盖索引</h1>
<h2 id="什么是覆盖索引？">什么是覆盖索引？</h2>
<p>理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。<br>
理解方式二：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。简单说就是， 索引列+主键 包含 SELECT 到 FROM之间查询的列。</p>
<h2 id="覆盖索引的利弊">覆盖索引的利弊</h2>
<p>好处：</p>
<ol>
<li>
<p>避免Innodb表进行索引的二次查询（回表）</p>
</li>
<li>
<p>可以把随机IO变成顺序IO加快查询效率</p>
</li>
</ol>
<p>弊端：<br>
索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p>
<h2 id="如何给字符串添加索引">如何给字符串添加索引</h2>
<p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table teacher add index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql&gt; alter table teacher add index index2(email(6));</span><br></pre></td></tr></table></figure>
<p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414224722266.png" alt="image-20220414224722266"></p>
<p>以及</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414224734281.png" alt="image-20220414224734281"></p>
<p>如果使用的是<strong>index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p>如果使用的是<strong>index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。<br>
也就是说使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。前面<br>
已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</li>
</ol>
<p>前缀索引对覆盖索引的影响</p>
<blockquote>
<p>结论：<br>
使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素</p>
</blockquote>
<h1>索引下推</h1>
<p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。</p>
<h2 id="在不使用ICP索引扫描的过程：">在不使用ICP索引扫描的过程：</h2>
<p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层<br>
server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222806887.png" alt="image-20220414222806887"></p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222812172.png" alt="image-20220414222812172"></p>
<h2 id="使用ICP扫描的过程：">使用ICP扫描的过程：</h2>
<ul>
<li>storage层：</li>
</ul>
<p>首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p>
<ul>
<li>server 层：</li>
</ul>
<p>对返回的数据，使用table filter条件做最后的过滤。</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222859129.png" alt="image-20220414222859129"></p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220414222904548.png" alt="image-20220414222904548"></p>
<h2 id="使用前后的成本差别">使用前后的成本差别</h2>
<p>使用前，存储层多返回了需要被index filter过滤掉的整行记录<br>
使用ICP后，直接就去掉了不满足index filter条件的记录，省去了他们回表和传递到server层的成本。<br>
ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</p>
<h2 id="ICP的使用条件">ICP的使用条件</h2>
<p>① <strong>只能用于二级索引</strong>(secondary index)<br>
②explain显示的执行计划中type值（join 类型）为range 、 ref 、 eq_ref 或者ref_or_null 。<br>
③ 并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。<br>
④ ICP可以用于MyISAM和InnnoDB存储引擎<br>
⑤ MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。<br>
⑥ 当SQL使用覆盖索引时，不支持ICP优化方法。</p>
<p>总结:</p>
<p>索引下推是使用index filter对使用index key查询出来的二级索引进行过滤，然后再回表，查询数据。</p>
<h2 id="其它查询优化策略">其它查询优化策略</h2>
<h3 id="EXISTS-和-IN-的区分">EXISTS 和 IN 的区分</h3>
<p>问题：<br>
不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p>回答:</p>
<p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A where cc in(select cc from B)</span><br><span class="line"></span><br><span class="line">select * from A where exists (select cc from B where B.cc = A.cc)</span><br></pre></td></tr></table></figure>
<p>当A小于B时，用exists。因为exists的实现，相当于外表循环，实现逻辑类似于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in A</span><br><span class="line">	for j in B</span><br><span class="line">		if(j.cc == i.cc) then ...</span><br></pre></td></tr></table></figure>
<p>当B小于A时用IN，因为实现的逻辑类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in B</span><br><span class="line">	for j in A</span><br><span class="line">			if j.cc=i.cc then ...</span><br></pre></td></tr></table></figure>
<p>那个表小就用那个表来驱动，A表小就用Exists，B表小就用IN</p>
<h3 id="COUNT-与COUNT-具体字段-效率">COUNT(*)与COUNT(具体字段)效率</h3>
<p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： <strong>SELECT COUNT(*) 、SELECT COUNT(1) 和SELECT COUNT(具体字段)</strong> ，使用这三者之间的查询效率是怎样的？</p>
<p>答:<br>
前提:如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p>
<p><strong>环节1:</strong></p>
<p>**COUNT(*)<strong>和</strong>COUNT(1)**都是对所有结果进行COUNT，COUNT(+)和COUNT(1)本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句，则是对数据表的数据行数进行统计。</p>
<p><strong>环节2:</strong></p>
<p>如果是<strong>MylSAM存储引擎</strong>，统计数据表的行数只需要0(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。如果是<strong>InnoDB存储引擎</strong>，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MylSAM一样，维护一个row_count变量，因此需要采用扫描全表，是0(n)的复杂度，进行循环＋计数的方式来完成统计<br>
<strong>环节3:</strong></p>
<p>在InnoDB引擎中，如果采用<strong>COUNT(具体字段)来统计数据行数</strong>，<strong>要尽量采用二级索引</strong>。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，<strong>明显会大于二级索引(非聚簇索引)</strong>。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用<strong>占用空间更小的二级索引</strong>来进行统计。</p>
<p>如果有多个二级索引，EXPLAIN会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h3 id="关于SELECT">关于SELECT(*)</h3>
<p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。</p>
<p>原因：<br>
① MySQL 在解析的过程中，会通过查询数据字典将&quot;*&quot;按序转换成所有列名，这会大大的耗费资源和时间。<br>
② 无法使用覆盖索引</p>
<h3 id="LIMIT-1-对优化的影响">LIMIT 1 对优化的影响</h3>
<p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。<br>
如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1 了。</p>
<h3 id="多使用COMMIT">多使用COMMIT</h3>
<p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放<br>
的资源而减少。<br>
COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo / undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ul>
<h1>淘宝数据库，主键如何设计的？</h1>
<h2 id="自增ID的问题">自增ID的问题</h2>
<p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<ol>
<li>可靠性不高<br>
存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</li>
<li>安全性不高<br>
对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</li>
<li>性能差<br>
自增ID的性能较差，需要在数据库服务器端生成。</li>
<li>交互多<br>
业务还需要额外执行一次类似last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li>
<li>局部唯一性<br>
最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</li>
</ol>
<h2 id="业务字段做主键">业务字段做主键</h2>
<p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。<br>
表数据如下：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416130752363.png" alt="image-20220416130752363"></p>
<p>在这个表里，哪个字段比较合适呢？</p>
<ul>
<li>选择卡号（cardno）</li>
</ul>
<p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来 标识一条会员记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE demo.membermaster</span><br><span class="line">-&gt; (</span><br><span class="line">-&gt; cardno CHAR(8) PRIMARY KEY, -- 会员卡号为主键</span><br><span class="line">-&gt; membername TEXT,</span><br><span class="line">-&gt; memberphone TEXT,</span><br><span class="line">-&gt; memberpid TEXT,</span><br><span class="line">-&gt; memberaddress TEXT,</span><br><span class="line">-&gt; sex TEXT,</span><br><span class="line">-&gt; birthday DATETIME</span><br><span class="line">-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>
<p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。<br>
但实际情况是， 会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。<br>
从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息，而导致系统内部数据不一致”的情况。因此，从信息系统层面上看是没问题的。但是从使用系统的业务层面来看，就有很大的问题 了，会对商家造成影响。<br>
比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店<br>
购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416130855353.png" alt="image-20220416130855353"></p>
<p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| 张三 | 书 | 1.000 | 89.00 | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| 王五 | 书 | 1.000 | 89.00 | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万不能把会员卡号当做主键。</p>
<ul>
<li>选择会员电话 或 身份证号</li>
</ul>
<p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情<br>
况。<br>
那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可问题是，身份证号属于个人隐私，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。<br>
<strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p>
<blockquote>
<p>经验：<br>
刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
<h2 id="淘宝的主键设计">淘宝的主键设计</h2>
<p>在淘宝的电商业务中，订单服务是一个核心业务。请问， 订单表的主键淘宝是如何设计的呢？是自增ID吗？<br>
打开淘宝，看一下订单信息：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416131118897.png" alt="image-20220416131118897"></p>
<p>从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br><span class="line">1431146631521308113</span><br></pre></td></tr></table></figure>
<p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p>
<p>大胆猜测，淘宝的订单ID设计应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单ID = 时间 + 去重字段 + 用户ID后6位尾号</span><br></pre></td></tr></table></figure>
<p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p>
<h2 id="推荐的主键设计">推荐的主键设计</h2>
<p><strong>非核心业务</strong>：对应表的主键自增ID，如告警、日志、监控等信息。<br>
<strong>核心业务</strong>：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。<br>
这里推荐最简单的一种主键设计：UUID。</p>
<p>UUID的特点：</p>
<p>全局唯一，占用36字节，数据无序，插入性能差。</p>
<p>认识UUID：</p>
<ul>
<li>为什么UUID是全局唯一的？</li>
<li>为什么UUID占用36个字节？</li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</span><br></pre></td></tr></table></figure>
<p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132130053.png" alt="image-20220416132130053"></p>
<p><strong>为什么UUID是全局唯一的？</strong><br>
在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1/100ns。<br>
时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。<br>
<strong>为什么UUID占用36个字节？</strong><br>
UUID根据字符串进行存储，设计时还带有无用&quot;-&quot;字符串，因此总共需要36个字节。<br>
<strong>为什么UUID是随机无序的呢？</strong><br>
因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。<br>
MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的&quot;-&quot;字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。<br>
可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行<br>
转化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132320362.png" alt="image-20220416132320362"></p>
<p>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了。全局唯一 + 单调递增，这不就是我们想要的主键！</p>
<p>有序UUID性能测试</p>
<p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？<br>
我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p>
<p><img src="https://edu-1395430748.oss-cn-beijing.aliyuncs.com/images/imgs/image-20220416132339362.png" alt="image-20220416132339362"></p>
<p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在业务端就可以生成。还可以进一步减少SQL的交互次数。<br>
另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现。<br>
另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p>如果不是MySQL8.0 怎么办？</p>
<p>手动赋值字段做主键！<br>
比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。<br>
可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。<br>
门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当 前会员编号的最大值。<br>
这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进 行操作，就解决了各门店添加会员时会员编号冲突的问题。</p>

      
    </div>
    
    
    

    

    

    
	<div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

	
	</div>
    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/11/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="next" title="性能分析工具的使用">
                <i class="fa fa-chevron-left"></i> 性能分析工具的使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="prev" title="数据库的设计规范">
                数据库的设计规范 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="张浩宇" />
            
              <p class="site-author-name" itemprop="name">张浩宇</p>
              <p class="site-description motion-element" itemprop="description">日积月累,积少成多</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">154</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhanghaoyu0724" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">数据准备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">索引失效案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D%E6%88%91%E6%9C%80%E7%88%B1"><span class="nav-number">2.1.</span> <span class="nav-text">全值匹配我最爱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text">最佳左前缀原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">主键插入顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%8A%A8%E6%88%96%E6%89%8B%E5%8A%A8-%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.4.</span> <span class="nav-text">计算、函数、类型转换(自动或手动)导致索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.5.</span> <span class="nav-text">类型转换导致索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.6.</span> <span class="nav-text">范围条件右边的列索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E-%E6%88%96%E8%80%85-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.7.</span> <span class="nav-text">不等于(!&#x3D; 或者&lt;&gt;)索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#is-null%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8Cis-not-null%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.8.</span> <span class="nav-text">is null可以使用索引，is not null无法使用索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#like%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.9.</span> <span class="nav-text">like以通配符%开头索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OR-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.10.</span> <span class="nav-text">OR 前后存在非索引的列，索引失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8utf8mb4"><span class="nav-number">2.11.</span> <span class="nav-text">数据库和表的字符集统一使用utf8mb4</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">关联查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-3"><span class="nav-number">3.1.</span> <span class="nav-text">数据准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text">采用左外连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.</span> <span class="nav-text">采用内连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">join语句原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E8%A1%A8%E5%92%8C%E8%A2%AB%E9%A9%B1%E5%8A%A8%E8%A1%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">驱动表和被驱动表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Nested-Loop-Join-%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.2.</span> <span class="nav-text">Simple Nested-Loop Join(简单嵌套循环连接)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Index-Nested-Loop-Join%EF%BC%88%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">3.4.3.</span> <span class="nav-text">Index Nested-Loop Join（索引嵌套循环连接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block-Nested-Loop-Join-%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.4.</span> <span class="nav-text">Block Nested-Loop Join(块嵌套循环连接)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">3.5.</span> <span class="nav-text">Join小结：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-join"><span class="nav-number">3.6.</span> <span class="nav-text">Hash join</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">子查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">排序优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98"><span class="nav-number">4.1.1.</span> <span class="nav-text">案例实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filesort%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">filesort算法：双路排序和单路排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">优化分页查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="nav-number">5.1.</span> <span class="nav-text">优化思路一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="nav-number">5.2.</span> <span class="nav-text">优化思路二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">优先考虑覆盖索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">什么是覆盖索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="nav-number">6.2.</span> <span class="nav-text">覆盖索引的利弊</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">6.3.</span> <span class="nav-text">如何给字符串添加索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">索引下推</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8ICP%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">在不使用ICP索引扫描的过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ICP%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">使用ICP扫描的过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E7%9A%84%E6%88%90%E6%9C%AC%E5%B7%AE%E5%88%AB"><span class="nav-number">7.3.</span> <span class="nav-text">使用前后的成本差别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.4.</span> <span class="nav-text">ICP的使用条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">7.5.</span> <span class="nav-text">其它查询优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EXISTS-%E5%92%8C-IN-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-number">7.5.1.</span> <span class="nav-text">EXISTS 和 IN 的区分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT-%E4%B8%8ECOUNT-%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5-%E6%95%88%E7%8E%87"><span class="nav-number">7.5.2.</span> <span class="nav-text">COUNT(*)与COUNT(具体字段)效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ESELECT"><span class="nav-number">7.5.3.</span> <span class="nav-text">关于SELECT(*)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">7.5.4.</span> <span class="nav-text">LIMIT 1 对优化的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%BD%BF%E7%94%A8COMMIT"><span class="nav-number">7.5.5.</span> <span class="nav-text">多使用COMMIT</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">淘宝数据库，主键如何设计的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%A2%9EID%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">自增ID的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="nav-number">8.2.</span> <span class="nav-text">业务字段做主键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E5%AE%9D%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.3.</span> <span class="nav-text">淘宝的主键设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.4.</span> <span class="nav-text">推荐的主键设计</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2021 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Hao Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">博客全站字数&#58;</span>
    
    <span title="博客全站字数">412.5k</span>
  
</div>











        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  

  

  
  

  

  

  

</body>
</html>
